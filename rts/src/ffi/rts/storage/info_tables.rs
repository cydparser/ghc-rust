use crate::ffi::rts::storage::closures::StgClosure;
use crate::ffi::stg::types::{StgCode, StgFun, StgHalfInt, StgHalfWord, StgInt, StgWord};
use crate::prelude::*;

#[cfg(test)]
mod tests;

pub(crate) const _HNF: u32 = 1;

pub(crate) const _BTM: u32 = 2;

pub(crate) const _NS: u32 = 4;

pub(crate) const _THU: u32 = 8;

pub(crate) const _MUT: u32 = 16;

pub(crate) const _UPT: u32 = 32;

pub(crate) const _SRT: u32 = 64;

pub(crate) const _IND: u32 = 128;

pub(crate) const _FRM: u32 = 256;

/// cbindgen:no-export
#[repr(C)]
#[cfg_attr(test, derive(Clone))]
pub struct StgProfInfo {
    closure_type_off: StgInt,
    closure_desc_off: StgInt,
}

#[cfg(test)]
impl Arbitrary for StgProfInfo {
    fn arbitrary(g: &mut Gen) -> Self {
        StgProfInfo {
            closure_type_off: Arbitrary::arbitrary(g),
            closure_desc_off: Arbitrary::arbitrary(g),
        }
    }
}

/// cbindgen:no-export
#[repr(C)]
pub struct StgLargeBitmap_ {
    size: StgWord,
    bitmap: __IncompleteArrayField<StgWord>,
}

#[ffi(ghc_lib, testsuite)]
pub type StgLargeBitmap = StgLargeBitmap_;

#[ffi(compiler, ghc_lib)]
#[repr(C)]
pub union StgClosureInfo {
    pub payload: StgClosureInfo__bindgen_ty_1,
    pub bitmap: StgWord,
    pub large_bitmap_offset: StgInt,
    pub selector_offset: StgWord,
}

#[ffi(compiler, ghc_lib)]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct StgClosureInfo__bindgen_ty_1 {
    pub ptrs: StgHalfWord,
    pub nptrs: StgHalfWord,
}

#[ffi(compiler, ghc_lib)]
pub type StgSRTField = StgHalfInt;

#[ffi(compiler, ghc_lib, libraries, testsuite)]
pub type StgInfoTable = StgInfoTable_;

#[ffi(compiler, ghc_lib)]
#[repr(C)]
pub struct StgInfoTable_ {
    pub layout: StgClosureInfo,
    pub type_: StgHalfWord,
    pub srt: StgSRTField,
    pub code: __IncompleteArrayField<StgCode>,
}

pub(crate) type StgInfoTablePtr = *mut StgInfoTable_;

#[ffi(compiler, ghc_lib)]
#[repr(C)]
pub struct StgFunInfoExtraRev_ {
    pub slow_apply_offset: StgInt,
    pub b: StgFunInfoExtraRev___bindgen_ty_1,
    pub fun_type: StgHalfWord,
    pub arity: StgHalfWord,
}

#[ffi(compiler, ghc_lib)]
#[repr(C)]
pub union StgFunInfoExtraRev___bindgen_ty_1 {
    pub bitmap: StgWord,
    pub bitmap_offset: StgInt,
}

#[ffi(compiler, ghc_lib, libraries)]
pub type StgFunInfoExtraRev = StgFunInfoExtraRev_;

#[ffi(compiler, ghc_lib)]
#[repr(C)]
pub struct StgFunInfoExtraFwd_ {
    pub fun_type: StgHalfWord,
    pub arity: StgHalfWord,
    pub srt: *mut StgClosure,
    pub b: StgFunInfoExtraFwd___bindgen_ty_1,
    pub slow_apply: StgFun,
}

#[ffi(compiler, ghc_lib)]
#[repr(C)]
pub union StgFunInfoExtraFwd___bindgen_ty_1 {
    pub bitmap: StgWord,
}

pub(crate) type StgFunInfoExtraFwd = StgFunInfoExtraFwd_;

#[ffi(compiler, ghc_lib, libraries)]
#[repr(C)]
pub struct StgFunInfoTable {
    pub f: StgFunInfoExtraRev,
    pub i: StgInfoTable,
}

// TODO(rust): Is this generated by Haskell in utils/genapply/Main.hs?
#[ffi(ghc_lib)]
#[unsafe(no_mangle)]
pub static stg_arg_bitmaps: [StgWord; 0] = [0; _];

#[ffi(ghc_lib)]
#[repr(C)]
pub struct StgRetInfoTable {
    pub i: StgInfoTable,
}

/// cbindgen:no-export
#[repr(C)]
pub struct StgThunkInfoTable_ {
    i: StgInfoTable,
}

pub(crate) type StgThunkInfoTable = StgThunkInfoTable_;

/// cbindgen:no-export
#[repr(C)]
pub struct StgConInfoTable_ {
    con_desc: StgInt,
    i: StgInfoTable,
}

#[ffi(ghc_lib, testsuite)]
pub type StgConInfoTable = StgConInfoTable_;
