use build_utils as utils;
use proc_macro2::Span;
use regex::Regex;
use std::collections::{BTreeMap, BTreeSet};
use std::path::Path;
use std::process::Command;
use syn::{Ident, Type};

pub fn main() {
    let ghc = utils::GhcDirs::new();

    let buf = {
        let mut buf = vec![];
        let bindings = ghc.rts_bindings(false);

        bindings.write(Box::new(&mut buf)).unwrap();

        buf
    };

    let visitor = {
        let mut visitor = SymbolVisitor::default();
        visitor.copy_types.extend(
            [
                "bool",
                "c_char",
                "c_double",
                "c_float",
                "c_int",
                "c_long",
                "c_longlong",
                "c_schar",
                "c_short",
                "c_uchar",
                "c_uint",
                "c_ulong",
                "c_ulonglong",
                "c_ushort",
                "char",
                "f128",
                "f16",
                "f32",
                "f64",
                "i128",
                "i16",
                "i32",
                "i64",
                "i8",
                "isize",
                "u128",
                "u16",
                "u32",
                "u64",
                "u8",
                "usize",
            ]
            .into_iter()
            .map(|s| Ident::new(s, Span::call_site())),
        );
        visitor.non_simple_types.extend(
            ["c_void", "pthread_cond_t", "pthread_mutex_t", "pthread_t"]
                .into_iter()
                .map(|s| Ident::new(s, Span::call_site())),
        );

        let code = std::str::from_utf8(&buf).unwrap();

        let file = syn::parse_file(code).unwrap();

        syn::visit::visit_file(&mut visitor, &file);

        visitor
    };

    let ghc_path = &ghc.root_dir;

    let symbols = find_places(&visitor, ghc_path);

    println!("//! Generated by `just generate-symbols`: do not modify by hand.\n");

    println!("#[derive(Clone, Copy, Debug)]\npub enum Place {{");
    for v in PLACE_VARIANTS {
        println!("{v:?} = {:#01$b},", v as u32, PLACE_VARIANTS.len() + 2);
    }
    println!("}}\n");

    println!(
        "pub(crate) static PLACE_VARIANTS: [Place; {}] = [",
        PLACE_VARIANTS.len()
    );
    for v in PLACE_VARIANTS {
        println!("    Place::{v:?},");
    }
    println!("];\n");

    println!("#[derive(Clone, Copy, Default)]\npub struct Places(pub(crate) u32);\n");

    print_static_array("SYMBOLS", "(&str, Places)", symbols.len(), symbols);
    println!();
    print_static_array(
        "POINTER_TYPES",
        "&str",
        visitor.pointer_types.len(),
        visitor.pointer_types.iter().map(Ident::to_string),
    );
    println!();
    print_static_array(
        "PRIMITIVE_TYPES",
        "&str",
        visitor.primitive_types.len(),
        visitor.primitive_types.iter().map(Ident::to_string),
    );
    println!();
    print_static_array(
        "OPTION_TYPES",
        "&str",
        visitor.option_types.len(),
        visitor.option_types.iter().map(Ident::to_string),
    );
    println!();
    print_static_array(
        "COPY_TYPES",
        "&str",
        visitor.copy_types.len(),
        visitor.copy_types.iter().map(Ident::to_string),
    );
    println!();
    print_static_array(
        "SIMPLE_TYPES",
        "&str",
        visitor.simple_types.len(),
        visitor.simple_types.iter().map(Ident::to_string),
    );
    println!();
    print_static_array(
        "NON_SIMPLE_TYPES",
        "&str",
        visitor.non_simple_types.len(),
        visitor.non_simple_types.iter().map(Ident::to_string),
    );
    println!();
    print_static_array(
        "STD_TYPES",
        "&str",
        visitor.std_types.len(),
        visitor.std_types.iter().map(Ident::to_string),
    );
}

#[derive(Debug, Default)]
struct SymbolVisitor {
    symbols: Vec<String>,
    variant_symbols: BTreeMap<String, String>,
    pointer_types: BTreeSet<Ident>,
    primitive_types: BTreeSet<Ident>,
    option_types: BTreeSet<Ident>,
    copy_types: BTreeSet<Ident>,
    simple_types: BTreeSet<Ident>,
    non_simple_types: BTreeSet<Ident>,
    std_types: BTreeSet<Ident>,
}

impl SymbolVisitor {
    fn add_symbol(&mut self, sym: String) {
        if sym != "_" {
            self.symbols.push(sym);
        }
    }

    pub fn is_primitive(&self, ident: &Ident) -> bool {
        self.primitive_types.contains(ident) || self.looks_primitive(ident)
    }

    fn looks_primitive(&self, ident: &Ident) -> bool {
        let s = ident.to_string();

        s.chars().next().is_some_and(char::is_lowercase)
            && ident != "c_void"
            && !is_bindgen(&s)
            && !self.non_simple_types.contains(ident)
    }

    /// True for paths/arrays/tuples containing only "simple" types.
    fn is_simple_type(&self, ty: &Type) -> bool {
        match ty {
            Type::Array(type_array) => self.is_simple_type(type_array.elem.as_ref()),
            Type::Path(type_path) => match type_path.path.get_ident() {
                Some(ident) if self.is_simple(ident) => true,
                _ => {
                    if let Some(ps) = type_path.path.segments.last() {
                        match &ps.arguments {
                            // Bindgen paths only contain one segment, so we only check for primitives here.
                            syn::PathArguments::None => self.is_primitive(&ps.ident),
                            syn::PathArguments::AngleBracketed(angle_args) => {
                                ps.ident == "Option"
                                    && matches!(angle_args.args.first(), Some(syn::GenericArgument::Type(param_ty)) if self.is_simple_type(param_ty))
                            }
                            syn::PathArguments::Parenthesized(_) => unreachable!(),
                        }
                    } else {
                        unreachable!()
                    }
                }
            },
            Type::Tuple(type_tuple) => type_tuple
                .elems
                .iter()
                .all(|param_ty| self.is_simple_type(param_ty)),
            _ => false,
        }
    }

    fn is_simple(&self, ident: &Ident) -> bool {
        self.simple_types.contains(ident) || self.is_primitive(ident)
    }

    fn all_fields_simple_types(&self, fields: &syn::Fields) -> bool {
        match fields {
            syn::Fields::Named(fields_named) => fields_named
                .named
                .iter()
                .all(|f| self.is_simple_type(&f.ty)),
            syn::Fields::Unnamed(fields_unnamed) => fields_unnamed
                .unnamed
                .iter()
                .all(|f| self.is_simple_type(&f.ty)),
            syn::Fields::Unit => true,
        }
    }

    fn maybe_insert_non_simple(&mut self, ident: &Ident) {
        if ident
            .to_string()
            .chars()
            .next()
            .is_some_and(char::is_lowercase)
        {
            self.non_simple_types.insert(ident.clone());
        }
    }

    fn is_std_type(&self, ty: &Type) -> bool {
        match ty {
            Type::Array(type_array) => self.is_std_type(type_array.elem.as_ref()),
            Type::BareFn(type_bare_fn) => {
                type_bare_fn
                    .inputs
                    .iter()
                    .all(|arg| self.is_std_type(&arg.ty))
                    && match &type_bare_fn.output {
                        syn::ReturnType::Default => true,
                        syn::ReturnType::Type(_, rty) => self.is_std_type(rty.as_ref()),
                    }
            }
            Type::Never(_) => true,
            Type::Path(type_path) => self.is_std_type_path(type_path),
            Type::Ptr(type_ptr) => self.is_std_type(type_ptr.elem.as_ref()),
            Type::Reference(type_ref) => self.is_std_type(type_ref.elem.as_ref()),
            ty => panic!("Unexpected type: {ty:?}"),
        }
    }

    fn is_std_type_path(&self, type_path: &syn::TypePath) -> bool {
        match type_path.path.segments.last() {
            None => unreachable!(),
            Some(ps) => {
                let ident = &ps.ident;

                match &ps.arguments {
                    syn::PathArguments::AngleBracketed(angle_args) => {
                        ident == "Option"
                            && matches!(angle_args.args.first(), Some(syn::GenericArgument::Type(param_ty)) if self.is_std_type(param_ty))
                    }
                    _ => self.is_std(ident),
                }
            }
        }
    }

    fn is_std(&self, ident: &Ident) -> bool {
        self.std_types.contains(ident) || self.is_primitive(ident) || ident == "c_void"
    }
}

#[rustfmt::skip]
#[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord)]
enum Place {
    Compiler  = 0b0000001,
    Docs      = 0b0000010,
    Driver    = 0b0000100,
    Libraries = 0b0001000,
    Testsuite = 0b0010000,
    Utils     = 0b0100000,
    GhcLib    = 0b1000000,
}

static PLACE_VARIANTS: [Place; 7] = [
    Place::Compiler,
    Place::Docs,
    Place::Driver,
    Place::Libraries,
    Place::Testsuite,
    Place::Utils,
    Place::GhcLib,
];

struct Places(BTreeSet<Place>);

impl Places {
    fn new() -> Self {
        Places(BTreeSet::new())
    }

    fn insert(&mut self, place: Place) {
        self.0.insert(place);
    }
}

impl std::fmt::Debug for Places {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut places: u32 = 0;

        for p in self.0.iter() {
            places |= *p as u32;
        }

        write!(f, "Places({:#0b})", places)
    }
}

impl<'ast> syn::visit::Visit<'ast> for SymbolVisitor {
    fn visit_foreign_item_fn(&mut self, i: &'ast syn::ForeignItemFn) {
        self.add_symbol(i.sig.ident.to_string());
    }

    fn visit_foreign_item_static(&mut self, i: &'ast syn::ForeignItemStatic) {
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_const(&mut self, i: &'ast syn::ItemConst) {
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum) {
        self.add_symbol(i.ident.to_string());
        self.copy_types.insert(i.ident.clone());

        if i.generics.params.is_empty()
            && i.variants
                .iter()
                .all(|v| self.all_fields_simple_types(&v.fields))
        {
            self.simple_types.insert(i.ident.clone());
        } else {
            self.maybe_insert_non_simple(&i.ident);
        }

        for v in &i.variants {
            self.variant_symbols
                .insert(v.ident.to_string(), i.ident.to_string());
        }
    }

    fn visit_item_static(&mut self, i: &'ast syn::ItemStatic) {
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct) {
        let s = i.ident.to_string();

        if !is_bindgen(&s) {
            self.add_symbol(s.clone());

            if i.generics.params.is_empty() && self.all_fields_simple_types(&i.fields) {
                match &i.fields {
                    syn::Fields::Named(fs)
                        if fs.named.len() == 1
                            && fs.named.first().is_some_and(|f| {
                                f.ident.as_ref().is_some_and(|i| i == "_unused")
                            }) =>
                    {
                        self.maybe_insert_non_simple(&i.ident)
                    }
                    _ => _ = self.simple_types.insert(i.ident.clone()),
                }
            } else {
                self.maybe_insert_non_simple(&i.ident);
            }
        }
    }

    fn visit_item_type(&mut self, i: &'ast syn::ItemType) {
        fn visit_type(visitor: &mut SymbolVisitor, ident: &Ident, ty: &Type) {
            if visitor.is_std_type(ty) {
                visitor.std_types.insert(ident.clone());
            }

            match ty {
                syn::Type::BareFn(_) => _ = visitor.pointer_types.insert(ident.clone()),
                syn::Type::Path(ty_path) => {
                    if let Some(ps) = ty_path.path.segments.last() {
                        if let syn::PathArguments::AngleBracketed(angle_args) = &ps.arguments {
                            if ps.ident == "Option"
                                && let Some(syn::GenericArgument::Type(param_ty)) =
                                    angle_args.args.first()
                            {
                                visitor.option_types.insert(ident.clone());
                                visit_type(visitor, ident, param_ty);
                            }
                        } else if visitor.is_primitive(&ps.ident) {
                            visitor.primitive_types.insert(ident.clone());

                            if visitor.copy_types.contains(&ps.ident) {
                                visitor.copy_types.insert(ident.clone());
                            }
                        } else if visitor.pointer_types.contains(&ps.ident) {
                            visitor.pointer_types.insert(ident.clone());
                        } else if visitor.is_simple_type(ty) {
                            visitor.simple_types.insert(ident.clone());
                        } else if visitor.non_simple_types.contains(&ps.ident) {
                            visitor.maybe_insert_non_simple(ident);
                        }
                    }
                }
                syn::Type::Ptr(_) => _ = visitor.pointer_types.insert(ident.clone()),
                syn::Type::Reference(_) => _ = visitor.pointer_types.insert(ident.clone()),
                _ => (),
            }
        }

        visit_type(self, &i.ident, &i.ty);
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_union(&mut self, i: &'ast syn::ItemUnion) {
        let s = i.ident.to_string();

        if !is_bindgen(&s) {
            self.add_symbol(s);
        }
    }

    fn visit_use_rename(&mut self, i: &'ast syn::UseRename) {
        self.add_symbol(i.rename.to_string());

        let ident = &i.ident;
        let rename = &i.rename;

        if self.is_primitive(ident) {
            self.primitive_types.insert(rename.clone());

            if self.copy_types.contains(ident) {
                self.copy_types.insert(rename.clone());
            }
        } else if self.pointer_types.contains(ident) {
            self.pointer_types.insert(rename.clone());
        } else if self.is_simple(ident) {
            self.simple_types.insert(rename.clone());
        } else if self.non_simple_types.contains(ident) {
            self.maybe_insert_non_simple(ident);
        }

        if self.is_std(ident) {
            self.std_types.insert(rename.clone());
        }
    }
}

fn is_bindgen(s: &str) -> bool {
    s.contains("__bindgen_")
}

fn find_places<P: AsRef<Path>>(visitor: &SymbolVisitor, path: P) -> BTreeMap<String, Places> {
    let path = path.as_ref();

    let syms_regex = &{
        let mut s = String::from(r"\b(");
        let mut add_sep = false;

        for sym in visitor.symbols.iter().chain(visitor.variant_symbols.keys()) {
            if add_sep {
                s.push('|');
            } else {
                add_sep = true;
            }
            s.push_str(sym);
        }
        s.push_str(r")\b");
        s
    };

    let search = |args: &[&str]| -> BTreeMap<String, Places> {
        let output = Command::new("rg")
            .current_dir(path)
            .args(["-g", "!/.gitlab"])
            .args(["-g", "!/bindisttest"])
            .args(["-g", "!/distrib"])
            .args(["-g", "!/ghc"])
            .args(["-g", "!/hadrian"])
            .args(["-g", "!/linters"])
            .args(["-g", "!/m4"])
            .args(["-g", "!/mk"])
            .args(["-g", "!/nofib"])
            .args(["-g", "!/rts"])
            .args(["-g", "!/rust"])
            .args(args)
            .output()
            .unwrap();

        if !output.status.success() {
            panic!(
                "ERROR: rg exited with error {:?}: {}",
                output.status.code(),
                String::from_utf8_lossy(&output.stderr)
            );
        }

        let mut sym_places = BTreeMap::new();

        match std::str::from_utf8(&output.stdout) {
            Ok(stdout) => {
                let regex = Regex::new(&format!(r"(?<sym>{})", syms_regex)).unwrap();

                for line in stdout.lines() {
                    let Some((file, s)) = line.split_once(':') else {
                        continue;
                    };
                    let s = s.trim();
                    // `rg` would not exclude -- comments for some reason.
                    if s.starts_with("-- ") {
                        continue;
                    }

                    for caps in regex.captures_iter(s) {
                        let key = {
                            let key = String::from(&caps["sym"]);
                            visitor.variant_symbols.get(&key).map_or(key, String::clone)
                        };

                        let places = sym_places.entry(key).or_insert_with(Places::new);

                        if let Some((place, rest)) = file.split_once("/") {
                            match place {
                                "compiler" => places.insert(Place::Compiler),
                                "docs" => places.insert(Place::Docs),
                                "driver" => places.insert(Place::Driver),
                                "libraries" => {
                                    if rest.starts_with("ghc-") {
                                        places.insert(Place::GhcLib)
                                    } else {
                                        places.insert(Place::Libraries)
                                    }
                                }
                                "testsuite" => places.insert(Place::Testsuite),
                                "utils" => places.insert(Place::Utils),
                                place => eprintln!("WARN: unexpected place {place}"),
                            };
                        }
                    }
                }
            }
            Err(err) => eprintln!("WARN: non-utf8: {err}"),
        }

        sym_places
    };

    let mut sym_places = search(&[
        "-g",
        "*.{c,h,hsc}",
        "--pcre2",
        &format!(r"^ *(?<!(//|/[*])).*{}", &syms_regex),
    ]);

    let foreign_pat = format!(
        r#"^(foreign +import +(ccall|javascript|prim) +(safe|unsafe)?.*| +data +){}"#,
        &syms_regex
    );

    let hs_places = search(&["-g", "*.hs", &foreign_pat]);

    let plain_symbols = syms_regex.to_string();

    let internal_places = search(&[
        "-g",
        "*.hs",
        &plain_symbols,
        "compiler",
        "libraries/ghc-bignum",
        "libraries/ghc-boot",
        "libraries/ghc-boot-th",
        "libraries/ghc-boot-th-next",
        "libraries/ghc-compact",
        "libraries/ghc-experimental",
        "libraries/ghc-heap",
        "libraries/ghc-internal",
        "libraries/ghc-platform",
        "libraries/ghc-prim",
        "utils/ghc-toolchain",
    ]);

    let doc_places = search(&[&plain_symbols, "docs/users_guide/exts/ffi.rst"]);

    // Merge the HashMaps.
    for ps in [hs_places, internal_places, doc_places] {
        for (sym, p) in ps {
            let places = sym_places.entry(sym).or_insert_with(Places::new);
            places.0.extend(&p.0);
        }
    }

    sym_places
}

fn print_static_array<T: std::fmt::Debug>(
    ident: &str,
    ty: &str,
    len: usize,
    symbols: impl IntoIterator<Item = T>,
) {
    println!("pub(crate) static {ident}: [{ty}; {len}] = [");

    for sym in symbols {
        println!("    {sym:?},");
    }
    println!("];");
}
