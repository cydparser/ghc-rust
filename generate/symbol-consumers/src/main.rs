use build_utils as utils;
use generate_consumers::{Consumer, Consumers};
use proc_macro2::Span;
use regex::Regex;
use std::collections::{BTreeMap, BTreeSet, HashMap};
use std::fs::File;
use std::io::Write as _;
use std::iter;
use std::path::Path;
use std::process::Command;
use syn::{Ident, Type};

pub fn main() {
    let symbols_path = {
        let generate_dir = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap();
        generate_dir.join("symbols/src/lib.rs")
    };

    let ghc = utils::GhcDirs::new();

    let buf = {
        let mut buf = vec![];
        let bindings = ghc.rts_bindings(false);

        bindings.write(Box::new(&mut buf)).unwrap();

        buf
    };

    let visitor = {
        let mut visitor = SymbolVisitor::default();
        visitor.copy_types.extend(
            [
                "bool",
                "c_char",
                "c_double",
                "c_float",
                "c_int",
                "c_long",
                "c_longlong",
                "c_schar",
                "c_short",
                "c_uchar",
                "c_uint",
                "c_ulong",
                "c_ulonglong",
                "c_ushort",
                "char",
                "f128",
                "f16",
                "f32",
                "f64",
                "i128",
                "i16",
                "i32",
                "i64",
                "i8",
                "isize",
                "u128",
                "u16",
                "u32",
                "u64",
                "u8",
                "usize",
            ]
            .into_iter()
            .map(|s| Ident::new(s, Span::call_site())),
        );
        visitor.non_simple_types.extend(
            ["c_void", "pthread_cond_t", "pthread_mutex_t", "pthread_t"]
                .into_iter()
                .map(|s| Ident::new(s, Span::call_site())),
        );

        let code = std::str::from_utf8(&buf).unwrap();

        let file = syn::parse_file(code).unwrap();

        syn::visit::visit_file(&mut visitor, &file);

        visitor
    };

    let ghc_path = &ghc.root_dir;

    let symbols = find_consumers(&visitor, ghc_path);

    let mut symbols_file = File::options()
        .write(true)
        .truncate(true)
        .open(symbols_path)
        .unwrap();

    writeln!(
        symbols_file,
        "//! Generated by 'just generate-symbols': just: do not modify by hand.\n"
    )
    .unwrap();

    print_static_array(
        &mut symbols_file,
        "SYMBOLS",
        "(&str, u32)",
        symbols.len(),
        symbols,
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "POINTER_TYPES",
        "&str",
        visitor.pointer_types.len(),
        visitor.pointer_types.iter().map(Ident::to_string),
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "PRIMITIVE_TYPES",
        "&str",
        visitor.primitive_types.len(),
        visitor.primitive_types.iter().map(Ident::to_string),
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "OPTION_TYPES",
        "&str",
        visitor.option_types.len(),
        visitor.option_types.iter().map(Ident::to_string),
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "COPY_TYPES",
        "&str",
        visitor.copy_types.len(),
        visitor.copy_types.iter().map(Ident::to_string),
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "SIMPLE_TYPES",
        "&str",
        visitor.simple_types.len(),
        visitor.simple_types.iter().map(Ident::to_string),
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "NON_SIMPLE_TYPES",
        "&str",
        visitor.non_simple_types.len(),
        visitor.non_simple_types.iter().map(Ident::to_string),
    )
    .unwrap();
    writeln!(symbols_file).unwrap();
    print_static_array(
        &mut symbols_file,
        "STD_TYPES",
        "&str",
        visitor.std_types.len(),
        visitor.std_types.iter().map(Ident::to_string),
    )
    .unwrap();
}

#[derive(Debug, Default)]
struct SymbolVisitor {
    symbols: Vec<String>,
    field_symbols: HashMap<String, Vec<String>>,
    field_types: HashMap<String, Vec<String>>,
    variant_symbols: HashMap<String, String>,
    pointer_types: BTreeSet<Ident>,
    primitive_types: BTreeSet<Ident>,
    option_types: BTreeSet<Ident>,
    copy_types: BTreeSet<Ident>,
    simple_types: BTreeSet<Ident>,
    non_simple_types: BTreeSet<Ident>,
    std_types: BTreeSet<Ident>,
}

impl SymbolVisitor {
    fn add_symbol(&mut self, sym: String) {
        if sym != "_" {
            self.symbols.push(sym);
        }
    }

    pub fn is_primitive(&self, ident: &Ident) -> bool {
        self.primitive_types.contains(ident) || self.looks_primitive(ident)
    }

    fn looks_primitive(&self, ident: &Ident) -> bool {
        let s = ident.to_string();

        s.chars().next().is_some_and(char::is_lowercase)
            && ident != "c_void"
            && !is_bindgen(&s)
            && !self.non_simple_types.contains(ident)
    }

    /// True for paths/arrays/tuples containing only "simple" types.
    fn is_simple_type(&self, ty: &Type) -> bool {
        match ty {
            Type::Array(type_array) => self.is_simple_type(type_array.elem.as_ref()),
            Type::Path(type_path) => match type_path.path.get_ident() {
                Some(ident) if self.is_simple(ident) => true,
                _ => {
                    if let Some(cs) = type_path.path.segments.last() {
                        match &cs.arguments {
                            // Bindgen paths only contain one segment, so we only check for primitives here.
                            syn::PathArguments::None => self.is_primitive(&cs.ident),
                            syn::PathArguments::AngleBracketed(angle_args) => {
                                cs.ident == "Option"
                                    && matches!(angle_args.args.first(), Some(syn::GenericArgument::Type(param_ty)) if self.is_simple_type(param_ty))
                            }
                            syn::PathArguments::Parenthesized(_) => unreachable!(),
                        }
                    } else {
                        unreachable!()
                    }
                }
            },
            Type::Tuple(type_tuple) => type_tuple
                .elems
                .iter()
                .all(|param_ty| self.is_simple_type(param_ty)),
            _ => false,
        }
    }

    fn is_simple(&self, ident: &Ident) -> bool {
        self.simple_types.contains(ident) || self.is_primitive(ident)
    }

    fn all_fields_simple_types(&self, fields: &syn::Fields) -> bool {
        match fields {
            syn::Fields::Named(fields_named) => fields_named
                .named
                .iter()
                .all(|f| self.is_simple_type(&f.ty)),
            syn::Fields::Unnamed(fields_unnamed) => fields_unnamed
                .unnamed
                .iter()
                .all(|f| self.is_simple_type(&f.ty)),
            syn::Fields::Unit => true,
        }
    }

    fn maybe_insert_non_simple(&mut self, ident: &Ident) {
        if ident
            .to_string()
            .chars()
            .next()
            .is_some_and(char::is_lowercase)
        {
            self.non_simple_types.insert(ident.clone());
        }
    }

    fn is_std_type(&self, ty: &Type) -> bool {
        match ty {
            Type::Array(type_array) => self.is_std_type(type_array.elem.as_ref()),
            Type::BareFn(type_bare_fn) => {
                type_bare_fn
                    .inputs
                    .iter()
                    .all(|arg| self.is_std_type(&arg.ty))
                    && match &type_bare_fn.output {
                        syn::ReturnType::Default => true,
                        syn::ReturnType::Type(_, rty) => self.is_std_type(rty.as_ref()),
                    }
            }
            Type::Never(_) => true,
            Type::Path(type_path) => self.is_std_type_path(type_path),
            Type::Ptr(type_ptr) => self.is_std_type(type_ptr.elem.as_ref()),
            Type::Reference(type_ref) => self.is_std_type(type_ref.elem.as_ref()),
            ty => panic!("Unexpected type: {ty:?}"),
        }
    }

    fn is_std_type_path(&self, type_path: &syn::TypePath) -> bool {
        match type_path.path.segments.last() {
            None => unreachable!(),
            Some(cs) => {
                let ident = &cs.ident;

                match &cs.arguments {
                    syn::PathArguments::AngleBracketed(angle_args) => {
                        ident == "Option"
                            && matches!(angle_args.args.first(), Some(syn::GenericArgument::Type(param_ty)) if self.is_std_type(param_ty))
                    }
                    _ => self.is_std(ident),
                }
            }
        }
    }

    fn is_std(&self, ident: &Ident) -> bool {
        self.std_types.contains(ident) || self.is_primitive(ident) || ident == "c_void"
    }
}

impl<'ast> syn::visit::Visit<'ast> for SymbolVisitor {
    fn visit_foreign_item_fn(&mut self, i: &'ast syn::ForeignItemFn) {
        self.add_symbol(i.sig.ident.to_string());
    }

    fn visit_foreign_item_static(&mut self, i: &'ast syn::ForeignItemStatic) {
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_const(&mut self, i: &'ast syn::ItemConst) {
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_enum(&mut self, i: &'ast syn::ItemEnum) {
        self.add_symbol(i.ident.to_string());
        self.copy_types.insert(i.ident.clone());

        if i.generics.params.is_empty()
            && i.variants
                .iter()
                .all(|v| self.all_fields_simple_types(&v.fields))
        {
            self.simple_types.insert(i.ident.clone());
        } else {
            self.maybe_insert_non_simple(&i.ident);
        }

        for v in &i.variants {
            self.variant_symbols
                .insert(v.ident.to_string(), i.ident.to_string());
        }
    }

    fn visit_item_static(&mut self, i: &'ast syn::ItemStatic) {
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_struct(&mut self, i: &'ast syn::ItemStruct) {
        let s = i.ident.to_string();

        if let syn::Fields::Named(fs) = &i.fields {
            add_fields(self, &s, fs);
        }

        if !is_bindgen(&s) {
            self.add_symbol(s.clone());

            if i.generics.params.is_empty() && self.all_fields_simple_types(&i.fields) {
                match &i.fields {
                    syn::Fields::Named(fs)
                        if fs.named.len() == 1
                            && fs.named.first().is_some_and(|f| {
                                f.ident.as_ref().is_some_and(|i| i == "_unused")
                            }) =>
                    {
                        self.maybe_insert_non_simple(&i.ident)
                    }
                    _ => {
                        self.simple_types.insert(i.ident.clone());
                    }
                }
            } else {
                self.maybe_insert_non_simple(&i.ident);
            }
        }
    }

    fn visit_item_type(&mut self, i: &'ast syn::ItemType) {
        fn visit_type(visitor: &mut SymbolVisitor, ident: &Ident, ty: &Type) {
            if visitor.is_std_type(ty) {
                visitor.std_types.insert(ident.clone());
            }

            match ty {
                syn::Type::BareFn(_) => _ = visitor.pointer_types.insert(ident.clone()),
                syn::Type::Path(ty_path) => {
                    if let Some(cs) = ty_path.path.segments.last() {
                        if let syn::PathArguments::AngleBracketed(angle_args) = &cs.arguments {
                            if cs.ident == "Option"
                                && let Some(syn::GenericArgument::Type(param_ty)) =
                                    angle_args.args.first()
                            {
                                visitor.option_types.insert(ident.clone());
                                visit_type(visitor, ident, param_ty);
                            }
                        } else if visitor.is_primitive(&cs.ident) {
                            visitor.primitive_types.insert(ident.clone());

                            if visitor.copy_types.contains(&cs.ident) {
                                visitor.copy_types.insert(ident.clone());
                            }
                        } else if visitor.pointer_types.contains(&cs.ident) {
                            visitor.pointer_types.insert(ident.clone());
                        } else if visitor.is_simple_type(ty) {
                            visitor.simple_types.insert(ident.clone());
                        } else if visitor.non_simple_types.contains(&cs.ident) {
                            visitor.maybe_insert_non_simple(ident);
                        }
                    }
                }
                syn::Type::Ptr(_) => _ = visitor.pointer_types.insert(ident.clone()),
                syn::Type::Reference(_) => _ = visitor.pointer_types.insert(ident.clone()),
                _ => (),
            }
        }

        visit_type(self, &i.ident, &i.ty);
        self.add_symbol(i.ident.to_string());
    }

    fn visit_item_union(&mut self, i: &'ast syn::ItemUnion) {
        let s = i.ident.to_string();

        add_fields(self, &s, &i.fields);
        self.add_symbol(s);
    }

    fn visit_use_rename(&mut self, i: &'ast syn::UseRename) {
        self.add_symbol(i.rename.to_string());

        let ident = &i.ident;
        let rename = &i.rename;

        if self.is_primitive(ident) {
            self.primitive_types.insert(rename.clone());

            if self.copy_types.contains(ident) {
                self.copy_types.insert(rename.clone());
            }
        } else if self.pointer_types.contains(ident) {
            self.pointer_types.insert(rename.clone());
        } else if self.is_simple(ident) {
            self.simple_types.insert(rename.clone());
        } else if self.non_simple_types.contains(ident) {
            self.maybe_insert_non_simple(ident);
        }

        if self.is_std(ident) {
            self.std_types.insert(rename.clone());
        }
    }
}

fn is_bindgen(s: &str) -> bool {
    s.contains("__bindgen_")
}

fn add_fields(visitor: &mut SymbolVisitor, name: &str, fields_named: &syn::FieldsNamed) {
    let fields_named = fields_named.named.iter();
    let field_count = fields_named.size_hint().0;
    let mut field_names = Vec::with_capacity(field_count);
    let mut field_types = Vec::with_capacity(field_count);

    for f in fields_named {
        let field_name = f.ident.as_ref().unwrap().to_string();

        if field_name == "c" || field_name == "h" || field_name == "_unused" {
            continue;
        }

        if let Type::Path(type_path) = &f.ty
            && let Some(ty_ident) = type_path.path.get_ident()
            && !visitor.looks_primitive(ty_ident)
            && ty_ident != "c_void"
        {
            field_types.push(ty_ident.to_string());
        }

        field_names.push(field_name);
    }

    if !field_names.is_empty() {
        visitor.field_symbols.insert(name.to_string(), field_names);

        if !field_types.is_empty() {
            visitor.field_types.insert(name.to_string(), field_types);
        }
    }
}

fn find_consumers<P: AsRef<Path>>(visitor: &SymbolVisitor, path: P) -> BTreeMap<String, Consumers> {
    let path = path.as_ref();

    let (syms_pattern, syms_and_fields_pattern) = {
        let mut syms_pattern = String::with_capacity(visitor.symbols.len() * 10);
        syms_pattern.push_str(r"\b(");
        interpolate_inplace(
            &mut syms_pattern,
            visitor.symbols.iter().chain(visitor.variant_symbols.keys()),
        );

        let mut syms_and_fields_pattern = syms_pattern.clone();
        syms_and_fields_pattern.push_str(r"|([.]|->)(");
        interpolate_inplace(
            &mut syms_and_fields_pattern,
            visitor.field_symbols.iter().flat_map(|(_, v)| v),
        );
        syms_and_fields_pattern.push_str(r"))\b");
        syms_pattern.push_str(r")\b");

        (syms_pattern, syms_and_fields_pattern)
    };

    let syms_regex = Regex::new(&format!(r"(?<sym>{})", syms_pattern)).unwrap();
    let syms_and_fields_regex =
        Regex::new(&format!(r"(?<sym>{})", syms_and_fields_pattern)).unwrap();

    let subs: HashMap<String, BTreeSet<(String, String)>> = {
        let mut subs: HashMap<String, BTreeSet<_>> = HashMap::with_capacity(1024);

        for (v, e) in visitor.variant_symbols.iter() {
            subs.insert(
                v.clone(),
                iter::once((e.clone(), format!("{}::{}", e, v))).collect(),
            );
        }

        for (name, fields) in visitor.field_symbols.iter() {
            for field in fields {
                let dot_field = format!(".{field}");
                let mut value: BTreeSet<_> =
                    iter::once((name.clone(), format!("{name}{dot_field}"))).collect();

                subs.entry(dot_field.clone())
                    .or_default()
                    .append(&mut value.clone());
                subs.entry(format!("->{}", field))
                    .or_default()
                    .append(&mut value);
            }
        }

        // Some fields, like 'header' and payload', are too common.
        subs.retain(|_, v| v.len() < 4);

        subs
    };

    let search = |syms_regex: &Regex, args: &[&str]| -> BTreeMap<String, Consumers> {
        let output = Command::new("rg")
            .current_dir(path)
            .arg("--with-filename")
            .args(["-g", "!/.gitlab"])
            .args(["-g", "!/bindisttest"])
            .args(["-g", "!/distrib"])
            .args(["-g", "!/ghc"])
            .args(["-g", "!/hadrian"])
            .args(["-g", "!/linters"])
            .args(["-g", "!/m4"])
            .args(["-g", "!/mk"])
            .args(["-g", "!/nofib"])
            .args(["-g", "!/rts"])
            .args(["-g", "!/rust"])
            .args(args)
            .output()
            .unwrap();

        if !output.status.success() {
            panic!(
                "ERROR: rg exited with error {:?}: {}",
                output.status.code(),
                String::from_utf8_lossy(&output.stderr)
            );
        }

        let mut sym_consumers = BTreeMap::new();

        match std::str::from_utf8(&output.stdout) {
            Ok(stdout) => {
                for line in stdout.lines() {
                    let Some((file, s)) = line.split_once(':') else {
                        continue;
                    };
                    let s = s.trim();
                    // 'rg' would not exclude -- comments for some reason.
                    if s.starts_with("-- ")
                        || s.starts_with("{-")
                        || s.starts_with("//")
                        || s.starts_with("/*")
                        || s.starts_with("#include")
                    {
                        continue;
                    }

                    for caps in syms_regex.captures_iter(s) {
                        let (main_keys, sub_keys) = {
                            let sym = String::from(&caps["sym"]);

                            match subs.get(&sym) {
                                Some(keys) => {
                                    keys.iter().map(|(k, s)| (k.clone(), s.clone())).collect()
                                }
                                None if !(sym.starts_with('.') || sym.starts_with("->")) => {
                                    (vec![sym], vec![])
                                }
                                _ => (vec![], vec![]),
                            }
                        };

                        let consumer = file.split_once("/").and_then(|(dir, rest)| match dir {
                            "compiler" => Some(Consumer::Compiler),
                            "docs" => Some(Consumer::Docs),
                            "driver" => Some(Consumer::Driver),
                            "libraries" => {
                                if rest.starts_with("ghc-") || rest.starts_with("ghci") {
                                    Some(Consumer::GhcLib)
                                } else {
                                    Some(Consumer::Libraries)
                                }
                            }
                            "testsuite" => Some(Consumer::Testsuite),
                            "utils" => Some(Consumer::Utils),
                            _ => None,
                        });

                        if let Some(consumer) = consumer {
                            for key in main_keys.into_iter().chain(sub_keys.into_iter()) {
                                sym_consumers
                                    .entry(key)
                                    .or_insert_with(Consumers::new)
                                    .insert(consumer);
                            }
                        }
                    }
                }
            }
            Err(err) => eprintln!("WARN: non-utf8: {err}"),
        }

        sym_consumers
    };

    let mut sym_consumers: BTreeMap<String, Consumers> = search(
        &syms_and_fields_regex,
        &["-g", "*.{c,h,hsc}", &syms_and_fields_pattern],
    );

    let foreign_pat = format!(
        r#"^(foreign +import +(ccall|javascript|prim) +(safe|unsafe)?.*| +data +){}"#,
        syms_pattern
    );

    let hs_consumers = search(&syms_regex, &["-g", "*.hs", &foreign_pat]);

    let internal_consumers = search(
        &syms_and_fields_regex,
        &[
            "-g",
            "*.hs",
            &syms_and_fields_pattern,
            "compiler",
            "libraries/ghc-bignum",
            "libraries/ghc-boot",
            "libraries/ghc-boot-th",
            "libraries/ghc-boot-th-next",
            "libraries/ghc-compact",
            "libraries/ghc-experimental",
            "libraries/ghc-heap",
            "libraries/ghc-internal",
            "libraries/ghc-platform",
            "libraries/ghc-prim",
            "utils/ghc-toolchain",
        ],
    );

    let doc_consumers = search(
        &syms_and_fields_regex,
        &[&syms_and_fields_pattern, "docs/users_guide/exts/ffi.rst"],
    );

    // Merge the HashMaps.
    for cs in [hs_consumers, internal_consumers, doc_consumers] {
        for (sym, c) in cs {
            *(sym_consumers.entry(sym).or_default()) |= c;
        }
    }

    // The fields of a composite type inherit the consumers of the composite type.
    for (sym, field_syms) in visitor.field_types.iter() {
        if let Some(c) = sym_consumers.get(sym).copied() {
            for field_sym in field_syms {
                *(sym_consumers.entry(field_sym.clone()).or_default()) |= c;
            }
        }
    }

    sym_consumers
}

fn interpolate_inplace<I, T>(string: &mut String, strings: I)
where
    I: IntoIterator<Item = T>,
    T: AsRef<str>,
{
    let strings = strings.into_iter();
    let mut add_sep = false;

    for pat in strings {
        if add_sep {
            string.push('|');
        } else {
            add_sep = true;
        }
        string.push_str(pat.as_ref());
    }
}

fn print_static_array<T: std::fmt::Debug>(
    file: &mut File,
    ident: &str,
    ty: &str,
    len: usize,
    symbols: impl IntoIterator<Item = T>,
) -> Result<(), Box<dyn std::error::Error>> {
    writeln!(file, "pub static {ident}: [{ty}; {len}] = [")?;

    for sym in symbols {
        writeln!(file, "    {sym:?},")?;
    }
    writeln!(file, "];")?;
    Ok(())
}
